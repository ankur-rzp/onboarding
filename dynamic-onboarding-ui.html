<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Onboarding System - Free Navigation</title>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        // Test if axios is loaded and provide fallback
        console.log('Axios loaded:', typeof axios);
        if (typeof axios === 'undefined') {
            console.error('Axios failed to load from CDN, trying fallback...');
            // Fallback: create a simple fetch-based axios-like object
            window.axios = {
                get: async (url) => {
                    const response = await fetch(url);
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return {
                        data: await response.json(),
                        status: response.status
                    };
                },
                post: async (url, data) => {
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(data)
                    });
                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }
                    return {
                        data: await response.json(),
                        status: response.status
                    };
                }
            };
            console.log('Fallback axios created');
        }
    </script>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8">
        <div class="max-w-6xl mx-auto">
            <h1 class="text-3xl font-bold text-gray-800 mb-8">Dynamic Onboarding System</h1>
            
            <!-- Graph Selection -->
            <div id="graph-selection" class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">Select Onboarding Type</h2>
                <div id="graphs-list" class="space-y-4">
                    <div class="text-center text-gray-600">Loading available graphs...</div>
                </div>
            </div>

            <!-- Main Onboarding Interface -->
            <div id="onboarding-interface" class="grid grid-cols-1 lg:grid-cols-3 gap-6" style="display: none;">
                
                <!-- Left Panel: Navigation Map -->
                <div class="lg:col-span-1">
                    <div class="bg-white rounded-lg shadow-md p-6 sticky top-4">
                        <h3 class="text-lg font-semibold text-gray-800 mb-4">Onboarding Map</h3>
                        <div class="text-sm text-gray-600 mb-4">
                            Session: <span id="session-id" class="font-mono"></span>
                        </div>
                        
                        <!-- Progress Overview -->
                        <div class="mb-6">
                            <div class="flex justify-between text-sm text-gray-600 mb-2">
                                <span>Progress</span>
                                <span id="progress-text">0/0</span>
                            </div>
                            <div class="w-full bg-gray-200 rounded-full h-2">
                                <div id="progress-bar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                            </div>
                        </div>

                        <!-- Node Navigation -->
                        <div id="node-navigation" class="space-y-2">
                            <!-- Nodes will be dynamically generated here -->
                        </div>

                        <!-- Quick Actions -->
                        <div class="mt-6 pt-4 border-t border-gray-200">
                            <h4 class="font-medium text-gray-800 mb-3">Quick Actions</h4>
                            <div class="space-y-2">
                                <button onclick="showRequiredOnly()" class="w-full text-left px-3 py-2 text-sm bg-yellow-50 text-yellow-800 rounded-lg hover:bg-yellow-100">
                                    üìã Show Required Only
                                </button>
                                <button onclick="showOptionalOnly()" class="w-full text-left px-3 py-2 text-sm bg-green-50 text-green-800 rounded-lg hover:bg-green-100">
                                    ‚úÖ Show Optional Only
                                </button>
                                <button onclick="showAllNodes()" class="w-full text-left px-3 py-2 text-sm bg-blue-50 text-blue-800 rounded-lg hover:bg-blue-100">
                                    üîç Show All Nodes
                                </button>
                                <button onclick="resetOnboarding()" class="w-full text-left px-3 py-2 text-sm bg-red-50 text-red-800 rounded-lg hover:bg-red-100">
                                    üîÑ Start Over
                                </button>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Right Panel: Current Node Form -->
                <div class="lg:col-span-2">
                    <div class="bg-white rounded-lg shadow-md p-6">
                        <div id="current-node-header" class="mb-6">
                            <!-- Current node information will be displayed here -->
                        </div>

                        <div id="error-message" class="bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded mb-4 hidden">
                            <!-- Error messages will be displayed here -->
                        </div>
                        <form id="node-form" class="space-y-6">
                            <div id="form-fields">
                                <!-- Form fields will be dynamically generated here -->
                            </div>
                            
                            <div class="flex flex-wrap gap-3">
                                <button type="submit" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">
                                    üíæ Save & Continue
                                </button>
                                <button type="button" onclick="saveAndStay()" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700">
                                    üíæ Save & Stay
                                </button>
                                <button type="button" onclick="skipNode()" id="skip-button" class="bg-yellow-600 text-white px-6 py-2 rounded-lg hover:bg-yellow-700" style="display: none;">
                                    ‚è≠Ô∏è Skip for Now
                                </button>
                                <button type="button" onclick="checkExistingUploadedFiles()" class="bg-purple-600 text-white px-4 py-2 rounded-lg hover:bg-purple-700 text-sm">
                                    üîç Check Files
                                </button>
                            </div>
                        </form>

                        <!-- Data Summary -->
                        <div id="data-summary" class="mt-8 pt-6 border-t border-gray-200">
                            <h4 class="font-medium text-gray-800 mb-3">Collected Data Summary</h4>
                            <div id="summary-content" class="text-sm text-gray-600">
                                <!-- Summary will be displayed here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Completion Screen -->
            <div id="completion" class="bg-white rounded-lg shadow-md p-6 text-center" style="display: none;">
                <div class="text-green-600 text-6xl mb-4">üéâ</div>
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Onboarding Complete!</h2>
                <p class="text-gray-600 mb-6">All required information has been collected successfully.</p>
                <button onclick="resetOnboarding()" class="bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700">
                    Start New Onboarding
                </button>
            </div>
        </div>
    </div>

    <script>
        const API_BASE = 'http://localhost:8080/api/v1';
        let currentSession = null;
        let currentGraph = null;
        let currentNode = null;
        let allNodes = [];
        let allEdges = [];
        let visitedNodes = new Set();
        let completedNodes = new Set();
        let eligibleNodes = [];

        // Initialize the application
        async function init() {
            console.log('Initializing application...');
            console.log('API_BASE:', API_BASE);
            console.log('axios available:', typeof axios);
            
            // Test basic connectivity
            try {
                console.log('Testing API connectivity...');
                const testResponse = await axios.get(`${API_BASE}/graphs`);
                console.log('API connectivity test successful:', testResponse.status);
                console.log('Response data:', testResponse.data);
            } catch (error) {
                console.error('API connectivity test failed:', error);
                console.error('Error details:', error.response?.data || error.message);
            }
            
            await loadGraphs();
        }
        

        // Show loading state
        function showLoader() {
            // Disable form buttons
            const buttons = document.querySelectorAll('#node-form button');
            buttons.forEach(button => {
                button.disabled = true;
                button.classList.add('opacity-50', 'cursor-not-allowed');
            });
        }

        // Hide loading state
        function hideLoader() {
            // Enable form buttons
            const buttons = document.querySelectorAll('#node-form button');
            buttons.forEach(button => {
                button.disabled = false;
                button.classList.remove('opacity-50', 'cursor-not-allowed');
            });
        }

        // Fetch eligible nodes from backend
        async function fetchEligibleNodes() {
            if (!currentSession || !currentSession.id) {
                console.log('No session available to fetch eligible nodes');
                return;
            }

            try {
                const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}/eligible-nodes`);
                eligibleNodes = response.data.eligible_nodes || [];
                console.log('Fetched eligible nodes:', eligibleNodes);
                
                // Update navigation map with new eligible nodes
                buildNavigationMap();
            } catch (error) {
                console.error('Error fetching eligible nodes:', error);
                // Fallback: allow all nodes except completion nodes
                eligibleNodes = allNodes
                    .filter(node => node.type !== 'end' && node.name !== 'Onboarding Complete')
                    .map(node => node.id);
            }
        }

        // Load available graphs
        async function loadGraphs() {
            try {
                console.log('Loading graphs from:', `${API_BASE}/graphs`);
                const response = await axios.get(`${API_BASE}/graphs`);
                const graphs = response.data;
                
                console.log('Received graphs:', graphs);
                
                const graphsList = document.getElementById('graphs-list');
                if (!graphsList) {
                    console.error('graphs-list element not found');
                    return;
                }
                
                if (!graphs || graphs.length === 0) {
                    graphsList.innerHTML = '<div class="text-center text-red-600">No graphs available</div>';
                    return;
                }

                graphsList.innerHTML = graphs.map(graph => `
                    <div class="border border-gray-200 rounded-lg p-4 hover:bg-gray-50 cursor-pointer transition-colors" onclick="selectGraph('${graph.id}')">
                        <h3 class="font-medium text-gray-800">${graph.name}</h3>
                        <p class="text-sm text-gray-600 mt-1">${graph.description}</p>
                        <div class="flex justify-between items-center mt-3">
                            <span class="text-xs text-gray-500">Graph ID: ${graph.id}</span>
                            <span class="text-xs bg-blue-100 text-blue-800 px-2 py-1 rounded">${Object.keys(graph.nodes).length} nodes</span>
                        </div>
                    </div>
                `).join('');
                
                console.log('Graphs loaded successfully');
            } catch (error) {
                console.error('Error loading graphs:', error);
                const graphsList = document.getElementById('graphs-list');
                if (graphsList) {
                    graphsList.innerHTML = `<div class="text-center text-red-600">Error loading graphs: ${error.message}</div>`;
                }
            }
        }

        // Select a graph and start onboarding
        async function selectGraph(graphId) {
            try {
                // Get graph details
                const graphResponse = await axios.get(`${API_BASE}/graphs/${graphId}`);
                currentGraph = graphResponse.data;
                allNodes = Object.values(currentGraph.nodes);
                allEdges = Object.values(currentGraph.edges);

                // Start session
                const sessionResponse = await axios.post(`${API_BASE}/sessions`, {
                    user_id: 'demo-user',
                    graph_id: graphId
                });
                
                currentSession = sessionResponse.data;
                clearError(); // Clear any previous errors
                
                // Hide graph selection, show onboarding interface
                document.getElementById('graph-selection').style.display = 'none';
                document.getElementById('onboarding-interface').style.display = 'grid';
                document.getElementById('session-id').textContent = currentSession.id;
                
                // Build navigation map
                buildNavigationMap();
                
                // Load current node
                await loadCurrentNode();
                
            } catch (error) {
                console.error('Error starting onboarding:', error);
            }
        }

        // Build the navigation map
        function buildNavigationMap() {
            const navigation = document.getElementById('node-navigation');
            navigation.innerHTML = allNodes.map(node => {
                const isVisited = visitedNodes.has(node.id);
                const isCompleted = completedNodes.has(node.id);
                const isCurrent = currentNode && currentNode.id === node.id;
                const isAvailable = isNodeAvailable(node);
                
                let statusClass = 'bg-gray-100 text-gray-600';
                let statusIcon = '‚≠ï';
                let clickHandler = `onclick="navigateToNode('${node.id}')"`;
                
                if (!isAvailable) {
                    statusClass = 'bg-gray-50 text-gray-400 cursor-not-allowed opacity-50';
                    statusIcon = 'üö´';
                    clickHandler = ''; // Disable clicking
                } else if (isCurrent) {
                    statusClass = 'bg-blue-100 text-blue-800 border-blue-300';
                    statusIcon = 'üìç';
                } else if (isCompleted) {
                    statusClass = 'bg-green-100 text-green-800 border-green-300';
                    statusIcon = '‚úÖ';
                } else if (isVisited) {
                    statusClass = 'bg-yellow-100 text-yellow-800 border-yellow-300';
                    statusIcon = 'üîÑ';
                }

                const requiredFields = node.fields.filter(f => f.required).length;
                const optionalFields = node.fields.filter(f => !f.required).length;
                
                return `
                    <div class="border rounded-lg p-3 transition-colors ${statusClass}" ${clickHandler}>
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <span class="text-sm">${statusIcon}</span>
                                <span class="text-sm font-medium">${node.name}</span>
                            </div>
                            <div class="text-xs">
                                ${requiredFields > 0 ? `<span class="text-red-600">${requiredFields}R</span>` : ''}
                                ${optionalFields > 0 ? `<span class="text-green-600">${optionalFields}O</span>` : ''}
                            </div>
                        </div>
                        <div class="text-xs mt-1 opacity-75">${node.type}</div>
                        ${!isAvailable ? '<div class="text-xs text-red-500 mt-1">Not available yet</div>' : ''}
                    </div>
                `;
            }).join('');
        }

        // Check if a node should be available for navigation
        function isNodeAvailable(node) {
            // Hide completion/end nodes - they should never be clickable
            if (node.type === 'end' || node.name === 'Onboarding Complete') {
                return false;
            }
            
            // If no user type selected, only show User Type Selection
            if (!currentSession || !currentSession.data || !currentSession.data.user_type) {
                return node.name === 'User Type Selection';
            }
            
            // Check if this node is in the eligible nodes list
            if (eligibleNodes && eligibleNodes.length > 0) {
                return eligibleNodes.includes(node.id);
            }
            
            // If it's the current node, it's always available
            if (currentNode && currentNode.id === node.id) {
                return true;
            }
            
            // Fallback: let backend handle all other navigation logic
            return true;
            
            // If it's completed, it's available for review
            if (completedNodes.has(node.id)) {
                return true;
            }
            
            // Start node is always available
            if (node.name === 'User Type Selection') {
                return true;
            }
            
            // If we haven't completed the user type selection, only show the start node
            const userTypeSelectionNode = allNodes.find(n => n.name === 'User Type Selection');
            if (userTypeSelectionNode && !completedNodes.has(userTypeSelectionNode.id)) {
                return false; // Only start node should be available
            }
            
            // If we have user type data, show nodes based on the selected path
            if (currentSession && currentSession.data && currentSession.data.user_type) {
                const userType = currentSession.data.user_type;
                
                if (userType === 'individual') {
                    // For individual users, hide company-specific nodes
                    if (node.name === 'Business Type' || node.name === 'Company Information') {
                        return false;
                    }
                } else if (userType === 'company') {
                    // For company users, hide individual-specific nodes
                    if (node.name === 'Personal Information') {
                        return false;
                    }
                }
            }
            
            // NEW LOGIC: Enable all possible paths based on current session state
            // Once user type is selected, enable most nodes for free navigation
            
            // If we have user type selected, enable most nodes
            if (currentSession && currentSession.data && currentSession.data.user_type) {
                // Enable all nodes except the ones explicitly blocked by user type
                const blockedNodes = [];
                
                if (currentSession.data.user_type === 'individual') {
                    blockedNodes.push('Business Type', 'Company Information');
                } else if (currentSession.data.user_type === 'company') {
                    blockedNodes.push('Personal Information');
                }
                
                // If this node is not blocked, it's available
                if (!blockedNodes.includes(node.name)) {
                    console.log(`‚úÖ Node ${node.name} is available (not blocked by user type)`);
                    return true;
                } else {
                    console.log(`‚ùå Node ${node.name} is blocked by user type: ${currentSession.data.user_type}`);
                }
            }
            
            // Fallback: if we don't have user type, use the old restrictive logic
            const nodeOrder = [
                'User Type Selection',
                'Personal Information', 'Business Type',
                'Company Information',
                'Contact Information',
                'Identity Documents',
                'Tax Information',
                'Bank Details',
                'Document Upload',
                'Onboarding Complete'
            ];
            
            const currentIndex = nodeOrder.indexOf(currentNode ? currentNode.name : 'User Type Selection');
            const nodeIndex = nodeOrder.indexOf(node.name);
            
            // Allow access to current node and next few nodes
            if (nodeIndex <= currentIndex + 2) {
                console.log(`‚úÖ Node ${node.name} is available (fallback logic: index ${nodeIndex} <= ${currentIndex + 2})`);
                return true;
            }
            
            console.log(`‚ùå Node ${node.name} is not available (fallback logic: index ${nodeIndex} > ${currentIndex + 2})`);
            return false;
        }

        // Navigate to a specific node
        async function navigateToNode(nodeId) {
            try {
                showLoader();
                
                // Check for ongoing uploads before navigation
                try {
                    const uploadsResponse = await axios.get(`${API_BASE}/sessions/${currentSession.id}/uploads`);
                    const ongoingUploads = uploadsResponse.data.filter(upload => upload.status === 'uploading');
                    
                    if (ongoingUploads.length > 0) {
                        const uploadNames = ongoingUploads.map(upload => upload.file_name).join(', ');
                        showError(`‚ö†Ô∏è Cannot navigate while uploads are in progress: ${uploadNames}. Please wait for uploads to complete.`);
                        return;
                    }
                } catch (error) {
                    console.warn('Could not check upload status:', error);
                }

                // Tell backend about the navigation - backend will decide if it's allowed
                await axios.post(`${API_BASE}/sessions/${currentSession.id}/navigate/${nodeId}`);
                
                // Reload current node from backend to get the actual state
                await loadCurrentNode();
                
            } catch (error) {
                console.error('Error navigating to node:', error);
                showError('Error navigating to node: ' + (error.response?.data?.message || error.message));
            } finally {
                hideLoader();
            }
        }

        // Save current form data without submitting to backend
        async function saveCurrentFormData() {
            if (!currentNode) return;
            
            const formData = new FormData(document.getElementById('node-form'));
            const data = {};
            
            // Collect all form data
            for (let [key, value] of formData.entries()) {
                data[key] = value || '';
            }
            
            // Update our local session data
            if (!currentSession.data) {
                currentSession.data = {};
            }
            Object.assign(currentSession.data, data);
        }

        // Clear subsequent path when a path-changing node is modified
        async function clearSubsequentPath() {
            console.log('Clearing subsequent path...');
            
            // Clear all completed nodes except the current one
            const currentCompletedNodes = Array.from(completedNodes);
            completedNodes.clear();
            completedNodes.add(currentNode.id); // Keep current node as completed
            
            // Clear visited nodes except the current one
            const currentVisitedNodes = Array.from(visitedNodes);
            visitedNodes.clear();
            visitedNodes.add(currentNode.id); // Keep current node as visited
            
            // Clear session data for subsequent nodes
            // Keep only the data from the current node and previous nodes
            const currentData = {};
            if (currentSession.data) {
                // Keep data from current node
                currentNode.fields.forEach(field => {
                    if (currentSession.data[field.id]) {
                        currentData[field.id] = currentSession.data[field.id];
                    }
                });
            }
            currentSession.data = currentData;
            
            console.log('Cleared subsequent path. Remaining completed nodes:', Array.from(completedNodes));
            console.log('Cleared session data:', currentSession.data);
        }

        // Check if onboarding is actually complete - let backend decide
        function isOnboardingActuallyComplete() {
            if (!currentSession || !currentSession.data) {
                console.log('No session or data available');
                return false;
            }
            
            // Check if we're already at the completion node
            const currentNode = allNodes.find(node => node.id === currentSession.current_node_id);
            if (currentNode && (currentNode.type === 'end' || currentNode.name === 'Onboarding Complete')) {
                console.log('Already at completion node');
                return true;
            }
            
            // Let backend decide by checking if we can reach completion
            // This is a simple check - if backend says we're done, we're done
            return false; // Backend will handle the actual completion logic
        }
        
        // Backend handles all validation - frontend just follows backend decisions
        
        // Evaluate edge condition based on current session data
        function evaluateEdgeCondition(edge, sessionData) {
            if (!edge.condition) {
                return true; // No condition means always true
            }
            
            const condition = edge.condition;
            
            switch (condition.type) {
                case 'always':
                    return true;
                    
                case 'field_value':
                    const fieldValue = sessionData[condition.field];
                    if (fieldValue === undefined) {
                        return false;
                    }
                    
                    switch (condition.operator) {
                        case 'eq':
                            return fieldValue === condition.value;
                        case 'in':
                            return Array.isArray(condition.value) && condition.value.includes(fieldValue);
                        case 'ne':
                            return fieldValue !== condition.value;
                        default:
                            return false;
                    }
                    
                case 'custom':
                    // For now, assume custom conditions are met if we have the required data
                    return true;
                    
                default:
                    return false;
            }
        }

        // Load current node from session
        async function loadCurrentNode() {
            try {
                // First check the session status
                const sessionResponse = await axios.get(`${API_BASE}/sessions/${currentSession.id}`);
                const session = sessionResponse.data;
                
                // If session is completed, show completion screen
                if (session.status === 'completed') {
                    console.log('Session is completed, showing completion screen');
                    showCompletion();
                    return;
                }
                
                const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}/current`);
                const node = response.data;
                
                currentNode = node;
                visitedNodes.add(node.id);
                
                // Also get the full session to understand available paths
                await loadSessionState();
                
                // Only fetch eligible nodes if we don't have them yet or if this is a new session
                if (!eligibleNodes || eligibleNodes.length === 0) {
                    await fetchEligibleNodes();
                }
                
                updateCurrentNodeHeader();
                generateFormFields();
                buildNavigationMap();
                updateProgress();
                updateDataSummary();
                
            } catch (error) {
                console.error('Error loading current node:', error);
            }
        }

        // Load session state to understand available paths
        async function loadSessionState() {
            try {
                const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}`);
                const session = response.data;
                
                console.log('Loading session state:', session);
                
                // Clear existing data
                currentSession.data = {};
                completedNodes.clear();
                visitedNodes.clear();
                
                // Update our understanding of completed nodes based on session history
                if (session.history) {
                    session.history.forEach(step => {
                        completedNodes.add(step.node_id);
                        visitedNodes.add(step.node_id);
                        
                        // Also preserve the data from each step
                        if (step.data) {
                            Object.assign(currentSession.data, step.data);
                        }
                    });
                }
                
                // Also load any current session data
                if (session.data) {
                    Object.assign(currentSession.data, session.data);
                }
                
                console.log('Loaded session data:', currentSession.data);
                console.log('Completed nodes:', Array.from(completedNodes));
                
                // Recalculate available paths after loading session data
                buildNavigationMap();
                
            } catch (error) {
                console.error('Error loading session state:', error);
            }
        }

        // Update current node header
        function updateCurrentNodeHeader() {
            if (!currentNode) return;
            
            const header = document.getElementById('current-node-header');
            const requiredFields = currentNode.fields.filter(f => f.required).length;
            const optionalFields = currentNode.fields.filter(f => !f.required).length;
            
            header.innerHTML = `
                <div class="flex items-center justify-between">
                    <div>
                        <h2 class="text-xl font-semibold text-gray-800">${currentNode.name}</h2>
                        <p class="text-gray-600 mt-1">${currentNode.description}</p>
                    </div>
                    <div class="text-right">
                        <div class="text-sm text-gray-500">Node Type</div>
                        <div class="text-sm font-medium text-gray-800">${currentNode.type}</div>
                    </div>
                </div>
                <div class="mt-4 flex space-x-4 text-sm">
                    <span class="bg-red-100 text-red-800 px-2 py-1 rounded">${requiredFields} Required</span>
                    <span class="bg-green-100 text-green-800 px-2 py-1 rounded">${optionalFields} Optional</span>
                </div>
            `;
        }

        // Generate form fields
        function generateFormFields() {
            if (!currentNode) return;
            
            const formFields = document.getElementById('form-fields');
            
            // Handle completion/end nodes differently
            if (currentNode.type === 'end') {
                showCompletion();
                return;
            }
            
            if (currentNode.fields && currentNode.fields.length > 0) {
                formFields.innerHTML = currentNode.fields.map(field => generateFieldHTML(field)).join('');
                
                // Populate fields with existing data from session after a small delay
                // to ensure the DOM is fully updated
                setTimeout(() => {
                    populateFormWithExistingData();
                    checkExistingUploadedFiles();
                }, 100); // Increased delay to ensure DOM is fully ready
            } else {
                formFields.innerHTML = '<p class="text-gray-600 text-center py-8">No input fields required for this step.</p>';
            }

            // Show/hide skip button based on whether there are required fields
            const skipButton = document.getElementById('skip-button');
            const hasRequiredFields = currentNode.fields && currentNode.fields.some(f => f.required);
            skipButton.style.display = hasRequiredFields ? 'none' : 'block';
        }

        // Populate form fields with existing data from session
        function populateFormWithExistingData() {
            if (!currentSession || !currentSession.data) {
                console.log('No session data to populate:', { currentSession, data: currentSession?.data });
                return;
            }
            
            console.log('Populating form with session data:', currentSession.data);
            console.log('Current node:', currentNode);
            
            // Populate each field with existing data
            Object.keys(currentSession.data).forEach(fieldId => {
                // Try to find the field by name attribute first, then by id
                let fieldElement = document.querySelector(`[name="${fieldId}"]`);
                if (!fieldElement) {
                    fieldElement = document.getElementById(fieldId);
                }
                
                console.log(`Looking for field ${fieldId}:`, fieldElement);
                
                if (fieldElement && currentSession.data[fieldId] !== undefined && currentSession.data[fieldId] !== '') {
                    if (fieldElement.type === 'checkbox' || fieldElement.type === 'radio') {
                        fieldElement.checked = currentSession.data[fieldId] === 'true' || currentSession.data[fieldId] === true;
                    } else {
                        fieldElement.value = currentSession.data[fieldId];
                    }
                    console.log(`‚úÖ Populated field ${fieldId} with value:`, currentSession.data[fieldId]);
                } else {
                    console.log(`‚ùå Field ${fieldId} not found or no data to populate`);
                }
            });
        }

        // Generate HTML for form fields
        function generateFieldHTML(field) {
            const baseClasses = "w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500";
            const requiredClass = field.required ? "border-red-300 focus:ring-red-500" : "border-gray-300 focus:ring-blue-500";
            
            const label = `
                <label class="block text-sm font-medium text-gray-700 mb-1">
                    ${field.name.replace(/_/g, ' ').toUpperCase()}
                    ${field.required ? '<span class="text-red-500 ml-1">*</span>' : '<span class="text-green-500 ml-1">(Optional)</span>'}
                </label>
            `;
            
            switch (field.type) {
                case 'select':
                    return `
                        <div class="space-y-2">
                            ${label}
                            <select name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''}>
                                <option value="">Select ${field.name.replace(/_/g, ' ')}</option>
                                ${field.options.map(option => `<option value="${option}">${option.replace(/_/g, ' ').toUpperCase()}</option>`).join('')}
                            </select>
                        </div>
                    `;
                case 'email':
                    return `
                        <div class="space-y-2">
                            ${label}
                            <input type="email" name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''} placeholder="Enter ${field.name.replace(/_/g, ' ')}">
                        </div>
                    `;
                case 'number':
                    return `
                        <div class="space-y-2">
                            ${label}
                            <input type="number" name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''} placeholder="Enter ${field.name.replace(/_/g, ' ')}">
                        </div>
                    `;
                case 'date':
                    return `
                        <div class="space-y-2">
                            ${label}
                            <input type="date" name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''}>
                        </div>
                    `;
                case 'file':
                    return `
                        <div class="space-y-2">
                            ${label}
                            <div class="file-upload-container" data-field-id="${field.id}">
                                <input type="file" name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''} onchange="handleFileSelect(this, '${field.id}')">
                                <input type="hidden" name="${field.id}_status" value="">
                                <input type="hidden" name="${field.id}_filename" value="">
                                <div class="filename-display mt-2 hidden" id="filename-${field.id}">
                                    <div class="flex items-center justify-between bg-green-50 border border-green-200 rounded-lg p-3">
                                        <div class="flex items-center">
                                            <svg class="w-5 h-5 text-green-600 mr-2" fill="currentColor" viewBox="0 0 20 20">
                                                <path fill-rule="evenodd" d="M4 4a2 2 0 012-2h4.586A2 2 0 0112 2.586L15.414 6A2 2 0 0116 7.414V16a2 2 0 01-2 2H6a2 2 0 01-2-2V4zm2 6a1 1 0 011-1h6a1 1 0 110 2H7a1 1 0 01-1-1zm1 3a1 1 0 100 2h6a1 1 0 100-2H7z" clip-rule="evenodd"></path>
                                            </svg>
                                            <span class="text-sm text-green-800 font-medium" id="filename-text-${field.id}"></span>
                                        </div>
                                        <button type="button" onclick="changeFile('${field.id}')" class="text-xs text-green-600 hover:text-green-800 underline">Change</button>
                                    </div>
                                </div>
                                <div class="upload-progress mt-2 hidden" id="progress-${field.id}">
                                    <div class="flex items-center space-x-2">
                                        <div class="flex-1 bg-gray-200 rounded-full h-2">
                                            <div class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%" id="progress-bar-${field.id}"></div>
                                        </div>
                                        <span class="text-sm text-gray-600" id="progress-text-${field.id}">0%</span>
                                    </div>
                                    <div class="text-xs text-gray-500 mt-1" id="progress-status-${field.id}">Ready to upload</div>
                                </div>
                                <div class="upload-success mt-2 hidden" id="success-${field.id}">
                                    <div class="flex items-center text-green-600">
                                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M16.707 5.293a1 1 0 010 1.414l-8 8a1 1 0 01-1.414 0l-4-4a1 1 0 011.414-1.414L8 12.586l7.293-7.293a1 1 0 011.414 0z" clip-rule="evenodd"></path>
                                        </svg>
                                        <span class="text-sm">Upload completed</span>
                                    </div>
                                </div>
                                <div class="upload-error mt-2 hidden" id="error-${field.id}">
                                    <div class="flex items-center text-red-600">
                                        <svg class="w-4 h-4 mr-1" fill="currentColor" viewBox="0 0 20 20">
                                            <path fill-rule="evenodd" d="M18 10a8 8 0 11-16 0 8 8 0 0116 0zm-7 4a1 1 0 11-2 0 1 1 0 012 0zm-1-9a1 1 0 00-1 1v4a1 1 0 102 0V6a1 1 0 00-1-1z" clip-rule="evenodd"></path>
                                        </svg>
                                        <span class="text-sm" id="error-text-${field.id}">Upload failed</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                default:
                    // Special handling for PAN and Aadhaar numbers
                    let inputType = 'text';
                    let placeholder = `Enter ${field.name.replace(/_/g, ' ')}`;
                    let maxLength = '';
                    let pattern = '';
                    
                    if (field.id === 'pan_number') {
                        inputType = 'text';
                        placeholder = 'Enter PAN (e.g., ABCDE1234F)';
                        maxLength = 'maxlength="10"';
                        pattern = 'pattern="[A-Z]{5}[0-9]{4}[A-Z]{1}"';
                    } else if (field.id === 'aadhaar_number') {
                        inputType = 'text';
                        placeholder = 'Enter Aadhaar (12 digits)';
                        maxLength = 'maxlength="12"';
                        pattern = 'pattern="[0-9]{12}"';
                    }
                    
                    return `
                        <div class="space-y-2">
                            ${label}
                            <input type="${inputType}" name="${field.id}" class="${baseClasses} ${requiredClass}" ${field.required ? 'required' : ''} placeholder="${placeholder}" ${maxLength} ${pattern}>
                        </div>
                    `;
            }
        }

        // Save and continue to next node
        document.getElementById('node-form').addEventListener('submit', async function(e) {
            e.preventDefault();
            await saveNodeData(true);
        });

        // Save and stay on current node
        async function saveAndStay() {
            await saveNodeData(false);
        }

        // Skip current node
        async function skipNode() {
            if (currentNode.fields.some(f => f.required)) {
                alert('Cannot skip node with required fields');
                return;
            }
            
            // Mark as completed and move to next available node
            completedNodes.add(currentNode.id);
            buildNavigationMap();
            updateProgress();
            updateDataSummary();
            
            // Find next incomplete node
            const nextNode = allNodes.find(node => !completedNodes.has(node.id));
            if (nextNode) {
                await navigateToNode(nextNode.id);
            } else {
                showCompletion();
            }
        }

        // Handle file selection and start upload
        async function handleFileSelect(input, fieldId) {
            console.log('handleFileSelect called with fieldId:', fieldId);
            const file = input.files[0];
            if (!file) {
                console.log('No file selected');
                return;
            }

            console.log('File selected:', file.name, 'Size:', file.size);
            
            // Show progress UI
            showUploadProgress(fieldId);
            
            // Start async upload
            await uploadFileAsync(file, fieldId);
        }

        // Show upload progress UI
        function showUploadProgress(fieldId) {
            console.log('showUploadProgress called with fieldId:', fieldId);
            const progressDiv = document.getElementById(`progress-${fieldId}`);
            const successDiv = document.getElementById(`success-${fieldId}`);
            const errorDiv = document.getElementById(`error-${fieldId}`);
            
            console.log('Progress div found:', progressDiv);
            console.log('Success div found:', successDiv);
            console.log('Error div found:', errorDiv);
            
            // Hide other states
            successDiv.classList.add('hidden');
            errorDiv.classList.add('hidden');
            
            // Show progress
            progressDiv.classList.remove('hidden');
            
            // Reset progress
            updateUploadProgress(fieldId, 0, 'Starting upload...');
        }

        // Update upload progress
        function updateUploadProgress(fieldId, progress, status) {
            const progressBar = document.getElementById(`progress-bar-${fieldId}`);
            const progressText = document.getElementById(`progress-text-${fieldId}`);
            const progressStatus = document.getElementById(`progress-status-${fieldId}`);
            
            progressBar.style.width = `${progress}%`;
            progressText.textContent = `${progress}%`;
            progressStatus.textContent = status;
        }

        // Show upload success
        function showUploadSuccess(fieldId) {
            try {
                console.log(`Showing upload success for field: ${fieldId}`);
                
                const progressDiv = document.getElementById(`progress-${fieldId}`);
                const successDiv = document.getElementById(`success-${fieldId}`);
                const errorDiv = document.getElementById(`error-${fieldId}`);
                
                // Hide other states
                if (progressDiv) progressDiv.classList.add('hidden');
                if (errorDiv) errorDiv.classList.add('hidden');
                
                // Show success
                if (successDiv) successDiv.classList.remove('hidden');
                
                // Mark the field as completed in the form data using a hidden input
                const hiddenInput = document.querySelector(`input[name="${fieldId}_status"]`);
                if (hiddenInput) {
                    hiddenInput.value = 'completed'; // Mark as completed
                    console.log(`Marked field ${fieldId} as completed in form data`);
                } else {
                    console.warn(`Hidden status input not found for fieldId: ${fieldId}`);
                }
                
                // Update the file input display to show uploaded status with filename
                const filename = response.data.filename || 'Uploaded file';
                updateFileInputDisplay(fieldId, 'File uploaded successfully', filename);
                
                // Update global upload status
                updateGlobalUploadStatus();
            } catch (error) {
                console.error('Error in showUploadSuccess:', error);
            }
        }
        
        // Update file input display to show uploaded status
        function updateFileInputDisplay(fieldId, status, filename = null) {
            try {
                // Find the file input container
                const fieldInput = document.querySelector(`input[name="${fieldId}"]`);
                if (!fieldInput) {
                    console.warn(`Field input not found for fieldId: ${fieldId}`);
                    return;
                }
                
                const fileInputContainer = fieldInput.closest('.file-upload-container');
                if (!fileInputContainer) {
                    console.warn(`File upload container not found for fieldId: ${fieldId}`);
                    return;
                }
                
                // If we have a filename, show the filename display
                if (filename) {
                    const filenameDisplay = document.getElementById(`filename-${fieldId}`);
                    const filenameText = document.getElementById(`filename-text-${fieldId}`);
                    const filenameHidden = document.querySelector(`input[name="${fieldId}_filename"]`);
                    
                    if (filenameDisplay && filenameText) {
                        filenameText.textContent = filename;
                        filenameDisplay.classList.remove('hidden');
                        
                        // Store filename in hidden input
                        if (filenameHidden) {
                            filenameHidden.value = filename;
                        }
                    }
                    
                    // Hide the file input and show success
                    fieldInput.style.display = 'none';
                } else {
                    // Find the "No file selected" text and update it
                    const noFileText = fileInputContainer.querySelector('.text-gray-500');
                    if (noFileText) {
                        noFileText.textContent = status;
                        noFileText.classList.remove('text-gray-500');
                        noFileText.classList.add('text-green-600');
                    }
                }
                
                // Remove red border and add green border to indicate success
                const fileInput = fileInputContainer.querySelector('input[type="file"]');
                if (fileInput) {
                    fileInput.classList.remove('border-red-300', 'focus:border-red-500', 'focus:ring-red-500');
                    fileInput.classList.add('border-green-300', 'focus:border-green-500', 'focus:ring-green-500');
                }
            } catch (error) {
                console.error('Error updating file input display:', error);
            }
        }
        
        // Function to change file (show file input again)
        function changeFile(fieldId) {
            try {
                const fieldInput = document.querySelector(`input[name="${fieldId}"]`);
                const filenameDisplay = document.getElementById(`filename-${fieldId}`);
                const filenameHidden = document.querySelector(`input[name="${fieldId}_filename"]`);
                
                if (fieldInput && filenameDisplay) {
                    // Show file input again
                    fieldInput.style.display = 'block';
                    fieldInput.value = ''; // Clear the file input
                    
                    // Hide filename display
                    filenameDisplay.classList.add('hidden');
                    
                    // Clear filename from hidden input
                    if (filenameHidden) {
                        filenameHidden.value = '';
                    }
                    
                    // Reset status
                    const statusHidden = document.querySelector(`input[name="${fieldId}_status"]`);
                    if (statusHidden) {
                        statusHidden.value = '';
                    }
                }
            } catch (error) {
                console.error('Error changing file:', error);
            }
        }
        
        // Check for existing uploaded files and update UI accordingly
        async function checkExistingUploadedFiles() {
            if (!currentSession || !currentSession.id || !currentNode) {
                console.log('Missing required data for checkExistingUploadedFiles');
                return;
            }
            
            try {
                console.log('Checking existing uploaded files for session:', currentSession.id);
                
                // Get uploaded files for this session
                const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}/uploads`);
                const uploadedFiles = response.data || [];
                
                console.log('Found uploaded files:', uploadedFiles);
                
                // Check each file field in the current node
                if (currentNode.fields) {
                    currentNode.fields.forEach(field => {
                        if (field.type === 'file') {
                            console.log(`Checking field: ${field.id}`);
                            
                            // Check if there's an uploaded file for this field
                            const uploadedFile = uploadedFiles.find(file => file.field_id === field.id);
                            if (uploadedFile && uploadedFile.status === 'completed') {
                                console.log(`Found completed upload for field: ${field.id}`);
                                
                                // Mark the field as completed using hidden input
                                const hiddenInput = document.querySelector(`input[name="${field.id}_status"]`);
                                if (hiddenInput) {
                                    hiddenInput.value = 'completed';
                                    console.log(`Marked field ${field.id} as completed`);
                                } else {
                                    console.warn(`Hidden input not found for field: ${field.id}`);
                                }
                                
                                // Update the UI to show uploaded status with filename
                                const filename = uploadedFile.filename || 'Uploaded file';
                                updateFileInputDisplay(field.id, 'File uploaded successfully', filename);
                                
                                // Also show the success indicator
                                const successDiv = document.getElementById(`success-${field.id}`);
                                if (successDiv) {
                                    successDiv.classList.remove('hidden');
                                }
                            } else {
                                console.log(`No completed upload found for field: ${field.id}`);
                            }
                        }
                    });
                }
            } catch (error) {
                console.warn('Could not check existing uploaded files:', error);
            }
        }

        // Show upload error
        function showUploadError(fieldId, errorMessage) {
            const progressDiv = document.getElementById(`progress-${fieldId}`);
            const successDiv = document.getElementById(`success-${fieldId}`);
            const errorDiv = document.getElementById(`error-${fieldId}`);
            const errorText = document.getElementById(`error-text-${fieldId}`);
            
            // Hide other states
            progressDiv.classList.add('hidden');
            successDiv.classList.add('hidden');
            
            // Show error
            errorText.textContent = errorMessage;
            errorDiv.classList.remove('hidden');
            
            // Update global upload status
            updateGlobalUploadStatus();
        }

        // Update global upload status indicator
        async function updateGlobalUploadStatus() {
            if (!currentSession) return;
            
            try {
                const uploadsResponse = await axios.get(`${API_BASE}/sessions/${currentSession.id}/uploads`);
                const ongoingUploads = uploadsResponse.data.filter(upload => upload.status === 'uploading');
                
                // Update the header to show upload status
                const headerElement = document.getElementById('current-node-header');
                if (headerElement) {
                    if (ongoingUploads.length > 0) {
                        const uploadNames = ongoingUploads.map(upload => upload.file_name).join(', ');
                        headerElement.innerHTML = `
                            <div class="flex items-center justify-between">
                                <h2 class="text-xl font-semibold text-gray-800">${currentNode ? currentNode.name : 'Loading...'}</h2>
                                <div class="flex items-center text-orange-600 bg-orange-100 px-3 py-1 rounded-full text-sm">
                                    <svg class="w-4 h-4 mr-2 animate-spin" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"></path>
                                    </svg>
                                    Uploading: ${uploadNames}
                                </div>
                            </div>
                        `;
                    } else {
                        // Reset to normal header
                        headerElement.innerHTML = `
                            <h2 class="text-xl font-semibold text-gray-800">${currentNode ? currentNode.name : 'Loading...'}</h2>
                        `;
                    }
                }
            } catch (error) {
                console.warn('Could not update global upload status:', error);
            }
        }

        // Upload file asynchronously
        async function uploadFileAsync(file, fieldId) {
            console.log('uploadFileAsync called with fieldId:', fieldId, 'file:', file.name);
            try {
                const formData = new FormData();
                formData.append('file', file);

                // Update global status when upload starts
                updateGlobalUploadStatus();

                console.log('Starting upload to:', `${API_BASE}/sessions/${currentSession.id}/upload/${fieldId}`);

                // Start upload
                const response = await axios.post(
                    `${API_BASE}/sessions/${currentSession.id}/upload/${fieldId}`,
                    formData,
                    {
                        headers: {
                            'Content-Type': 'multipart/form-data',
                        },
                        onUploadProgress: (progressEvent) => {
                            const progress = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                            console.log('Upload progress:', progress);
                            updateUploadProgress(fieldId, progress, 'Uploading file...');
                        }
                    }
                );

                console.log('Upload response:', response.data);

                if (response.data.success) {
                    console.log(`Upload started successfully for field: ${fieldId}`);
                    
                    // Upload started successfully, now poll for progress
                    updateUploadProgress(fieldId, 100, 'File uploaded, processing...');
                    pollUploadProgress(fieldId);
                    
                    // Mark the field as filled in the form data using a hidden input
                    const hiddenInput = document.querySelector(`input[name="${fieldId}_status"]`);
                    if (hiddenInput) {
                        hiddenInput.value = 'uploaded'; // Mark as uploaded
                        console.log(`Marked field ${fieldId} as uploaded in form data`);
                    } else {
                        console.warn(`Hidden status input not found for fieldId: ${fieldId}`);
                    }
                    
                    // Update the file input display to show uploading status
                    const filename = file.name || 'Uploading file...';
                    updateFileInputDisplay(fieldId, 'File uploaded, processing...', filename);
                } else {
                    showUploadError(fieldId, 'Upload failed: ' + (response.data.error || 'Unknown error'));
                }
            } catch (error) {
                console.error('Upload error:', error);
                const errorMessage = error.response?.data?.error || error.message || 'Upload failed';
                showUploadError(fieldId, errorMessage);
            }
        }

        // Poll upload progress
        async function pollUploadProgress(fieldId) {
            let pollCount = 0;
            const pollInterval = setInterval(async () => {
                pollCount++;
                try {
                    const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}/upload/${fieldId}/progress`);
                    const progress = response.data;
                    
                    console.log('Polling progress:', progress); // Debug log
                    
                    if (progress.status === 'uploading') {
                        // Show processing progress with timer
                        updateUploadProgress(fieldId, progress.progress, `Processing file... (${pollCount}s)`);
                        updateGlobalUploadStatus();
                    } else if (progress.status === 'completed') {
                        clearInterval(pollInterval);
                        updateUploadProgress(fieldId, 100, 'Upload completed');
                        setTimeout(() => showUploadSuccess(fieldId), 500);
                        updateGlobalUploadStatus();
                    } else if (progress.status === 'failed') {
                        clearInterval(pollInterval);
                        showUploadError(fieldId, progress.error || 'Upload failed');
                        updateGlobalUploadStatus();
                    }
                } catch (error) {
                    console.warn('Failed to poll upload progress:', error);
                    // If we can't get progress, assume it's still processing
                    updateUploadProgress(fieldId, 100, `Processing file... (${pollCount}s)`);
                }
            }, 1000); // Poll every second

            // Clear interval after 35 seconds to prevent infinite polling
            setTimeout(() => {
                clearInterval(pollInterval);
            }, 35000);
        }

        // Check upload progress for a field
        async function checkUploadProgress(fieldId) {
            try {
                const response = await axios.get(`${API_BASE}/sessions/${currentSession.id}/upload/${fieldId}/progress`);
                const progress = response.data;
                
                if (progress.status === 'uploading') {
                    updateUploadProgress(fieldId, progress.progress, 'Uploading...');
                } else if (progress.status === 'completed') {
                    showUploadSuccess(fieldId);
                } else if (progress.status === 'failed') {
                    showUploadError(fieldId, progress.error || 'Upload failed');
                }
            } catch (error) {
                console.error('Failed to check upload progress:', error);
            }
        }

        // Save node data
        async function saveNodeData(continueToNext = true) {
            try {
                // Get current node from backend to ensure we're saving the right node
                const currentResponse = await axios.get(`${API_BASE}/sessions/${currentSession.id}/current`);
                const backendCurrentNode = currentResponse.data;
            
            const formData = new FormData(document.getElementById('node-form'));
            const data = {};
            
            console.log('Form data entries:');
            for (let [key, value] of formData.entries()) {
                console.log(`  ${key}: ${value}`);
                data[key] = value || ''; // Include empty values as empty strings
            }
            
            // Also collect from all inputs in the current node to ensure we don't miss anything
            const allInputs = document.querySelectorAll('#form-fields input, #form-fields select, #form-fields textarea');
            console.log('All inputs found:', allInputs.length);
            allInputs.forEach(input => {
                if (input.name) {
                    if (input.type === 'checkbox' || input.type === 'radio') {
                        data[input.name] = input.checked;
                        console.log(`  ${input.name} (${input.type}): ${input.checked}`);
                    } else {
                        data[input.name] = input.value || '';
                        console.log(`  ${input.name} (${input.type}): ${input.value}`);
                    }
                }
            });
            
            // Ensure we have all required fields from the current node
            if (backendCurrentNode.fields) {
                backendCurrentNode.fields.forEach(field => {
                    if (field.required && !data.hasOwnProperty(field.id)) {
                        data[field.id] = '';
                    }
                });
            }
            
            // Preserve existing session data for fields not in current node
            if (currentSession.data) {
                Object.keys(currentSession.data).forEach(key => {
                    if (!data.hasOwnProperty(key)) {
                        data[key] = currentSession.data[key];
                    }
                });
            }
            
            // Preprocess PAN and Aadhaar numbers to ensure correct format
            if (data.pan_number && data.pan_number.trim()) {
                data.pan_number = data.pan_number.toUpperCase().trim();
                console.log('PAN number processed:', data.pan_number);
            }
            if (data.aadhaar_number && data.aadhaar_number.trim()) {
                data.aadhaar_number = data.aadhaar_number.replace(/\D/g, ''); // Remove non-digits
                console.log('Aadhaar number processed:', data.aadhaar_number);
            }
            
            // Ensure user_type is properly set for validation
            if (data.user_type) {
                console.log('User type in data:', data.user_type);
            } else if (currentSession.data && currentSession.data.user_type) {
                data.user_type = currentSession.data.user_type;
                console.log('User type from session:', data.user_type);
            }
            
            // Only remove truly empty optional fields (not required fields)
            Object.keys(data).forEach(key => {
                const value = data[key];
                const isRequired = backendCurrentNode.fields?.some(f => f.id === key && f.required);
                
                // Remove empty optional fields, but keep required fields even if empty
                if (!isRequired && (!value || value.toString().trim() === '')) {
                    delete data[key];
                }
            });

            console.log('Saving data for node:', backendCurrentNode.name, data);
            console.log('Required fields:', backendCurrentNode.fields?.map(f => ({id: f.id, required: f.required})));
            console.log('Completed nodes:', Array.from(completedNodes));

            try {
                // Check if we're changing a critical node that affects the path
                const isPathChangingNode = currentNode && (
                    currentNode.name === 'User Type Selection' || 
                    currentNode.name === 'Business Type'
                );
                
                if (isPathChangingNode) {
                    // Check if the data has changed in a way that affects the path
                    const oldValue = currentSession.data[currentNode.fields[0]?.id];
                    const newValue = data[currentNode.fields[0]?.id];
                    
                    if (oldValue && oldValue !== newValue) {
                        console.log(`Path-changing node data changed from ${oldValue} to ${newValue}, backend will handle path logic`);
                        // Backend handles all path logic - no need for complex path clearing
                    }
                }
                
                // Backend handles all navigation logic - no need for complex sync
                
                // Check for ongoing uploads before saving to backend
                try {
                    const uploadsResponse = await axios.get(`${API_BASE}/sessions/${currentSession.id}/uploads`);
                    const ongoingUploads = uploadsResponse.data.filter(upload => upload.status === 'uploading');
                    
                    if (ongoingUploads.length > 0) {
                        const uploadNames = ongoingUploads.map(upload => upload.file_name).join(', ');
                        showError(`‚ö†Ô∏è Cannot save while uploads are in progress: ${uploadNames}. Please wait for uploads to complete.`);
                        return;
                    }
                } catch (error) {
                    console.warn('Could not check upload status:', error);
                    // Continue with save attempt - backend will handle the validation
                }

                // Normal flow: save to backend
                const response = await axios.post(`${API_BASE}/sessions/${currentSession.id}/submit`, data);
                
                // If successful, mark as completed
                completedNodes.add(backendCurrentNode.id);
                
                // Update our session data with the submitted data
                if (!currentSession.data) {
                    currentSession.data = {};
                }
                Object.assign(currentSession.data, data);
                
                // Recalculate available paths after data update
                buildNavigationMap();
                
                // If this was User Type Selection, fetch eligible nodes from backend
                if (backendCurrentNode.name === 'User Type Selection') {
                    console.log('User type selection completed, fetching eligible nodes...');
                    await fetchEligibleNodes();
                }
                
                // Let backend handle completion detection - check if current node is completion node
                const currentSaveNode = allNodes.find(node => node.id === currentSession.current_node_id);
                if (currentSaveNode && (currentSaveNode.type === 'end' || currentSaveNode.name === 'Onboarding Complete')) {
                    console.log('Backend says onboarding is complete after save, showing completion screen');
                    showCompletion();
                }
                
                if (continueToNext) {
                    // Check if the session is completed first
                    if (response.data.metadata && response.data.metadata.session_status === 'completed') {
                        console.log('Session completed, showing completion screen');
                        showCompletion();
                    } else if (response.data.next_node_id) {
                        // Navigate to the specific next node determined by the backend
                        const nextNode = allNodes.find(n => n.id === response.data.next_node_id);
                        if (nextNode) {
                            // Check if this is the completion node
                            if (nextNode.name === 'Onboarding Complete' || nextNode.type === 'end') {
                                console.log('Navigating to completion node, showing completion screen');
                                showCompletion();
                            } else {
                                // Directly navigate to the backend's determined next node
                                console.log(`Backend determined next node: ${nextNode.name}, navigating directly`);
                                currentNode = nextNode;
                                visitedNodes.add(nextNode.id);
                                updateCurrentNodeHeader();
                                generateFormFields();
                                buildNavigationMap();
                                updateProgress();
                                updateDataSummary();
                            }
                        } else {
                            // Fallback: reload current node from backend
                            await loadCurrentNode();
                        }
                    } else {
                        // No next node, check if we're complete
                        showCompletion();
                    }
                } else {
                    // Just refresh the current view without changing the node
                    updateCurrentNodeHeader();
                    generateFormFields(); // This will populate with saved data
                    buildNavigationMap();
                    updateProgress();
                    updateDataSummary();
                }
                
            } catch (error) {
                console.error('Error saving data:', error);
                console.log('Error response:', error.response?.data);
                console.log('Error status:', error.response?.status);
                
                // Handle specific upload conflict error
                if (error.response?.status === 409) {
                    showError('‚ö†Ô∏è ' + (error.response.data || 'Cannot save while uploads are in progress. Please wait for uploads to complete.'));
                    return;
                }
                
                // Handle completion blocking - check if this is a "missing required nodes" error
                if (error.response?.data?.error && error.response.data.error.includes('cannot complete onboarding yet')) {
                    // This means the backend is trying to complete but missing required nodes
                    // The backend should have automatically navigated to the missing node
                    // Let's reload the current node to see where we are now
                    console.log('Completion blocked due to missing required nodes, reloading current node...');
                    
                    // Force a complete reload of the current node and UI state
                    await loadCurrentNode();
                    await loadGraph();
                    buildNavigationMap();
                    updateProgress();
                    updateDataSummary();
                    
                    // Show a helpful message about what's happening
                    const missingNodes = error.response.data.error.match(/\[(.*?)\]/);
                    if (missingNodes) {
                        showInfo(`üìã Please complete the following steps: ${missingNodes[1]}. You've been automatically taken to the next required step.`);
                    } else {
                        showInfo('üìã Please complete the required steps. You\'ve been automatically taken to the next required step.');
                    }
                    return;
                }
                
                // Handle validation errors that might indicate UI-backend sync issues
                if (error.response?.data?.error && error.response.data.error.includes('validation failed')) {
                    // Check if this might be a UI-backend sync issue
                    // The backend might have navigated to a different node than what the UI thinks
                    console.log('Validation failed, checking if UI is out of sync with backend...');
                    
                    // Preserve current form data before reloading
                    const currentFormData = {};
                    const allInputs = document.querySelectorAll('#form-fields input, #form-fields select, #form-fields textarea');
                    allInputs.forEach(input => {
                        if (input.name) {
                            if (input.type === 'checkbox' || input.type === 'radio') {
                                currentFormData[input.name] = input.checked;
                            } else {
                                currentFormData[input.name] = input.value;
                            }
                        }
                    });
                    
                    console.log('Preserved form data before reload:', currentFormData);
                    
                    // Force a complete reload of the current node and UI state
                    await loadCurrentNode();
                    await loadGraph();
                    buildNavigationMap();
                    updateProgress();
                    updateDataSummary();
                    
                    // Restore the preserved form data after a short delay
                    setTimeout(() => {
                        console.log('Restoring preserved form data:', currentFormData);
                        Object.keys(currentFormData).forEach(fieldId => {
                            const fieldElement = document.querySelector(`[name="${fieldId}"]`);
                            if (fieldElement) {
                                if (fieldElement.type === 'checkbox' || fieldElement.type === 'radio') {
                                    fieldElement.checked = currentFormData[fieldId];
                                } else {
                                    fieldElement.value = currentFormData[fieldId];
                                }
                                console.log(`‚úÖ Restored field ${fieldId} with value:`, currentFormData[fieldId]);
                            }
                        });
                    }, 150); // Slightly longer delay to ensure form is fully generated
                    
                    // Show a helpful message
                    showInfo('üîÑ The system has automatically taken you to the next required step. Please fill in the required information.');
                    return;
                }
                
                // Show detailed validation errors for other cases
                let errorMessage = 'Error saving data: ';
                if (error.response?.data?.message) {
                    errorMessage += error.response.data.message;
                } else if (error.response?.data?.error) {
                    errorMessage += error.response.data.error;
                } else if (error.response?.data?.errors) {
                    // Handle validation errors array
                    const errors = error.response.data.errors;
                    const errorDetails = errors.map(err => `${err.field}: ${err.message}`).join(', ');
                    errorMessage += `Validation failed: ${errorDetails}`;
                } else {
                    errorMessage += error.message;
                }
                
                // Show error in the UI instead of alert
                showError(errorMessage);
            }
        } catch (error) {
            console.error('Error in saveNodeData:', error);
            showError('Failed to save data: ' + error.message);
        }
        }

        // Update progress
        function updateProgress() {
            const totalNodes = allNodes.length;
            const completedCount = completedNodes.size;
            const progressPercent = totalNodes > 0 ? (completedCount / totalNodes) * 100 : 0;
            
            document.getElementById('progress-text').textContent = `${completedCount}/${totalNodes}`;
            document.getElementById('progress-bar').style.width = `${progressPercent}%`;
        }

        // Update data summary
        function updateDataSummary() {
            const summary = document.getElementById('summary-content');
            const completedNodeNames = Array.from(completedNodes).map(nodeId => {
                const node = allNodes.find(n => n.id === nodeId);
                return node ? node.name : nodeId;
            });
            
            if (completedNodeNames.length === 0) {
                summary.innerHTML = '<p class="text-gray-500">No data collected yet.</p>';
            } else {
                summary.innerHTML = `
                    <div class="space-y-2">
                        ${completedNodeNames.map(name => `
                            <div class="flex items-center space-x-2">
                                <span class="text-green-600">‚úÖ</span>
                                <span class="text-sm">${name}</span>
                            </div>
                        `).join('')}
                    </div>
                `;
            }
        }

        // Show completion screen
        function showCompletion() {
            document.getElementById('onboarding-interface').style.display = 'none';
            document.getElementById('completion').style.display = 'block';
        }

        // Show error message
        function showError(message) {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                errorDiv.scrollIntoView({ behavior: 'smooth' });
            } else {
                alert(message); // Fallback to alert if error div doesn't exist
            }
        }

        // Show info message (for completion guidance)
        function showInfo(message) {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.textContent = message;
                errorDiv.style.display = 'block';
                errorDiv.style.backgroundColor = '#e3f2fd'; // Light blue background
                errorDiv.style.color = '#1976d2'; // Blue text
                errorDiv.style.border = '1px solid #bbdefb';
                errorDiv.scrollIntoView({ behavior: 'smooth' });
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    clearError();
                }, 5000);
            } else {
                alert(message); // Fallback to alert if error div doesn't exist
            }
        }

        // Clear error message
        function clearError() {
            const errorDiv = document.getElementById('error-message');
            if (errorDiv) {
                errorDiv.style.display = 'none';
                // Reset styling
                errorDiv.style.backgroundColor = '';
                errorDiv.style.color = '';
                errorDiv.style.border = '';
            }
        }

        // Filter functions
        function showRequiredOnly() {
            // Highlight nodes with required fields
            const nodes = document.querySelectorAll('#node-navigation > div');
            nodes.forEach(node => {
                const hasRequired = node.textContent.includes('R');
                node.style.opacity = hasRequired ? '1' : '0.3';
            });
        }

        function showOptionalOnly() {
            // Highlight nodes with only optional fields
            const nodes = document.querySelectorAll('#node-navigation > div');
            nodes.forEach(node => {
                const hasRequired = node.textContent.includes('R');
                const hasOptional = node.textContent.includes('O');
                node.style.opacity = (!hasRequired && hasOptional) ? '1' : '0.3';
            });
        }

        function showAllNodes() {
            // Show all nodes
            const nodes = document.querySelectorAll('#node-navigation > div');
            nodes.forEach(node => {
                node.style.opacity = '1';
            });
        }

        // Reset onboarding
        function resetOnboarding() {
            currentSession = null;
            currentGraph = null;
            currentNode = null;
            allNodes = [];
            visitedNodes.clear();
            completedNodes.clear();
            
            document.getElementById('graph-selection').style.display = 'block';
            document.getElementById('onboarding-interface').style.display = 'none';
            document.getElementById('completion').style.display = 'none';
            
            loadGraphs();
        }

        // Initialize when page loads
        console.log('Script loaded, calling init...');
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                console.log('DOM ready, initializing...');
                init().catch(error => {
                    console.error('Init failed:', error);
                    alert('Failed to initialize: ' + error.message);
                });
            });
        } else {
            console.log('DOM already ready, initializing...');
            init().catch(error => {
                console.error('Init failed:', error);
                alert('Failed to initialize: ' + error.message);
            });
        }
        
        // Test timeout removed - loadGraphs() should handle the display
    </script>
</body>
</html>
